document.addEventListener("DOMContentLoaded", function () {
  // Form elements
  const postForm = document.getElementById("posts");
  const titleInput = document.getElementById("title");
  const tagsInput = document.getElementById("tags");
  const contentInput = document.getElementById("content"); // Hidden textarea for form submission
  const contentEditor = document.getElementById("content-editor"); // Rich text editor
  const resetBtn = document.querySelector(".reset-btn");
  const titleCount = document.getElementById("titleCount");
  
  // Format buttons
  const boldBtn = document.getElementById("bold");
  const italicBtn = document.getElementById("italic");
  const underlineBtn = document.getElementById("underline");
  const clearSelectedBtn = document.getElementById("clear-selected");
  const resetFormatBtn = document.getElementById("reset-format");
  
  // Initialize editor with focus handling
  if (contentEditor) {
    // Focus handling to show/hide placeholder
    contentEditor.addEventListener('focus', function() {
      if (contentEditor.innerHTML.trim() === '') {
        contentEditor.innerHTML = '';
      }
    });
    
    contentEditor.addEventListener('blur', function() {
      // Update hidden textarea with content for form submission
      updateHiddenContent();
      
      // Show placeholder if empty
      if (contentEditor.innerHTML.trim() === '') {
        contentEditor.innerHTML = '';
      }
    });
    
    // Listen for content changes in the editor
    contentEditor.addEventListener('input', function() {
      updateHiddenContent();
      clearError(contentInput, "contentErr");
    });
    
    // Initialize with empty content
    contentEditor.innerHTML = '';
    
    // Set up selection change monitoring to update button states
    document.addEventListener('selectionchange', updateButtonStates);
  }
  
  // Title character count update
  titleInput.addEventListener("input", function() {
    const count = titleInput.value.length;
    titleCount.textContent = `${count}/80 characters`;
    
    // Reset classes
    titleCount.classList.remove("warning", "danger");
    
    // Add warning color if approaching limit
    if (count > 70 && count <= 80) {
      titleCount.classList.add("warning");
    } else if (count > 80) {
      titleCount.classList.add("danger");
      // Display error about character limit
      displayError(titleInput, "titleError", "Title cannot exceed 80 characters");
    } else {
      // Clear error if title is within limits and not empty
      if (titleInput.value.trim() !== "") {
        clearError(titleInput, "titleError");
      }
    }
  });

  // Clear tag error when input changes
  tagsInput.addEventListener("input", function() {
    if (tagsInput.value.trim() !== "") {
      clearError(tagsInput, "tagsError");
    }
  });
  
  // Formatting button event handlers
  if (boldBtn) {
    boldBtn.addEventListener('click', function() {
      document.execCommand('bold', false, null);
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  if (italicBtn) {
    italicBtn.addEventListener('click', function() {
      document.execCommand('italic', false, null);
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  if (underlineBtn) {
    underlineBtn.addEventListener('click', function() {
      document.execCommand('underline', false, null);
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  // Clear formatting for selected text
  if (clearSelectedBtn) {
    clearSelectedBtn.addEventListener('click', function() {
      document.execCommand('removeFormat', false, null);
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  // Reset all formatting in the editor
  if (resetFormatBtn) {
    resetFormatBtn.addEventListener('click', function() {
      // Store the plain text
      const plainText = contentEditor.textContent || '';
      // Replace the content with plain text
      contentEditor.textContent = plainText;
      updateHiddenContent();
      contentEditor.focus();
    });
  }
  
  // Function to update hidden textarea with editor content for form submission
  function updateHiddenContent() {
    if (contentInput && contentEditor) {
      contentInput.value = contentEditor.innerHTML;
    }
  }
  
  // Update button states based on current text formatting
  function updateButtonStates() {
    if (!contentEditor) return;
    
    // Only update if editor is focused to avoid unnecessary updates
    if (document.activeElement === contentEditor) {
      if (boldBtn) boldBtn.classList.toggle('active', document.queryCommandState('bold'));
      if (italicBtn) italicBtn.classList.toggle('active', document.queryCommandState('italic'));
      if (underlineBtn) italicBtn.classList.toggle('active', document.queryCommandState('underline'));
    }
  }

  // Form validation
  postForm.addEventListener("submit", function(event) {
    event.preventDefault();
    
    // Update hidden content field before validation
    updateHiddenContent();
    
    // Clear all previous errors
    clearError(titleInput, "titleError");
    clearError(tagsInput, "tagsError");
    clearError(contentInput, "contentErr");
    
    let isValid = true;
    
    // Title validation
    if (!titleInput.value.trim()) {
      displayError(titleInput, "titleError", "Title cannot be empty");
      isValid = false;
    } else if (titleInput.value.length > 80) {
      displayError(titleInput, "titleError", "Title cannot exceed 80 characters");
      isValid = false;
    }
    
    // Tags validation
    if (!tagsInput.value.trim()) {
      displayError(tagsInput, "tagsError", "Please provide at least one tag");
      isValid = false;
    }
    
    // Content validation
    if (!contentEditor.textContent.trim()) {
      displayError(contentInput, "contentErr", "Post content cannot be empty");
      contentEditor.focus();
      isValid = false;
    }
    
    if (isValid) {
      // Ensure the hidden input has the latest content for form submission
      updateHiddenContent();
      
      // Convert to markdown if needed (for storing formatted content)
      const markdownContent = htmlToMarkdown(contentInput.value);
      
      // Simulate successful submission
      alert("Post submitted successfully!\n\nIn this demo, we're redirecting to the home page.");
      
      // Submit the form (redirects to index.html as per form action)
      this.submit();
    }
  });
  
  // Reset form handling
  resetBtn.addEventListener("click", function() {
    // Reset content editor
    contentEditor.innerHTML = '';
    
    // Update hidden textarea
    updateHiddenContent();
    
    // Reset format buttons visual state
    if (boldBtn) boldBtn.classList.remove("active");
    if (italicBtn) italicBtn.classList.remove("active");
    if (underlineBtn) underlineBtn.classList.remove("active");
    
    // Clear textarea validation styling
    clearError(titleInput, "titleError");
    clearError(tagsInput, "tagsError");
    clearError(contentInput, "contentErr");
    
    // Reset character count display
    titleCount.textContent = "0/80 characters";
    titleCount.classList.remove("warning", "danger");
  });
  
  // Add mouseup and keyup listeners to contentEditor to update button states
  if (contentEditor) {
    contentEditor.addEventListener('mouseup', updateButtonStates);
    contentEditor.addEventListener('keyup', function(e) {
      updateButtonStates();
      
      // Also update hidden content
      updateHiddenContent();
    });
  }
  
  // Helper function to convert HTML to Markdown (simplified version)
  function htmlToMarkdown(html) {
    // This is a very simplified converter - for production use a proper library
    let markdown = html
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<\/?strong>|<\/?b>/gi, '**')
      .replace(/<\/?em>|<\/?i>/gi, '*')
      .replace(/<\/?u>/gi, '__')
      .replace(/<\/?[^>]+(>|$)/g, ''); // Remove any remaining HTML tags
    
    return markdown;
  }
  
  // Helper functions for error handling
  function displayError(inputElement, errorId, errorMessage) {
    const errorElement = document.getElementById(errorId);
    if (errorElement) {
      errorElement.textContent = errorMessage;
      inputElement.classList.add("error");
    }
  }
  
  function clearError(inputElement, errorId) {
    const errorElement = document.getElementById(errorId);
    if (errorElement) {
      errorElement.textContent = "";
      inputElement.classList.remove("error");
    }
  }
});
