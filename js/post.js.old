document.addEventListener("DOMContentLoaded", function () {
  // Form elements
  const postForm = document.getElementById("posts");
  const titleInput = document.getElementById("title");
  const tagsInput = document.getElementById("tags");
  const contentInput = document.getElementById("content");
  const contentEditor = document.getElementById("content-editor");
  const resetBtn = document.querySelector(".reset-btn");
  const titleCount = document.getElementById("titleCount");
  
  // Format buttons
  const boldBtn = document.getElementById("bold");
  const italicBtn = document.getElementById("italic");
  const underlineBtn = document.getElementById("underline");
  const clearSelectedBtn = document.getElementById("clear-selected");
  const resetFormatBtn = document.getElementById("reset-format");
  
  // Initialize editor with focus handling
  if (contentEditor) {
    // Focus handling to show/hide placeholder
    contentEditor.addEventListener('focus', function() {
      if (contentEditor.innerHTML.trim() === '') {
        contentEditor.innerHTML = '';
      }
    });
    
    contentEditor.addEventListener('blur', function() {
      // Update hidden textarea with content for form submission
      updateHiddenContent();
    });
    
    // Listen for content changes in the editor
    contentEditor.addEventListener('input', function() {
      updateHiddenContent();
      clearError(contentInput, "contentErr");
    });
  }  // Title character count update
  titleInput.addEventListener("input", function() {
    const count = titleInput.value.length;
    titleCount.textContent = `${count}/80 characters`;
    
    // Reset classes
    titleCount.classList.remove("warning", "danger");
    
    // Add warning color if approaching limit
    if (count > 70 && count <= 80) {
      titleCount.classList.add("warning");
    } else if (count > 80) {
      titleCount.classList.add("danger");
      // Display error about character limit
      displayError(titleInput, "titleError", "Title cannot exceed 80 characters");
    } else {
      // Clear error if title is within limits and not empty
      if (titleInput.value.trim() !== "") {
        clearError(titleInput, "titleError");
      }
    }
  });

  // Clear tag error when input changes
  tagsInput.addEventListener("input", function() {
    if (tagsInput.value.trim() !== "") {
      clearError(tagsInput, "tagsError");
    }
  });
  
  // Formatting button event handlers
  if (boldBtn) {
    boldBtn.addEventListener('click', function() {
      document.execCommand('bold', false, null);
      this.classList.toggle('active');
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  if (italicBtn) {
    italicBtn.addEventListener('click', function() {
      document.execCommand('italic', false, null);
      this.classList.toggle('active');
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  if (underlineBtn) {
    underlineBtn.addEventListener('click', function() {
      document.execCommand('underline', false, null);
      this.classList.toggle('active');
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  // Clear formatting for selected text
  if (clearSelectedBtn) {
    clearSelectedBtn.addEventListener('click', function() {
      // Remove all formatting from selected text
      document.execCommand('removeFormat', false, null);
      contentEditor.focus();
      updateHiddenContent();
    });
  }
  
  // Reset all formatting in the editor
  if (resetFormatBtn) {
    resetFormatBtn.addEventListener('click', function() {
      // Store the plain text
      const plainText = contentEditor.textContent || '';
      // Replace the content with plain text
      contentEditor.textContent = plainText;
      updateHiddenContent();
      contentEditor.focus();
    });
  }
  
  // Function to update hidden textarea with editor content for form submission
  function updateHiddenContent() {
    if (contentInput && contentEditor) {
      contentInput.value = contentEditor.innerHTML;
    }
  }// Handle content changes and adjust formatted regions
  function handleContentChange(e) {
    // Get cursor position
    const cursorPos = contentInput.selectionStart;
    const previousContent = e.target.previousValue || '';
    const currentContent = contentInput.value;
    const previousLength = previousContent.length;
    const currentLength = currentContent.length;
    const changeInLength = currentLength - previousLength;
    
    // Handle text replacement (when text is selected and then replaced)
    if (e.inputType === "insertText" || e.inputType === "insertFromPaste") {
      const selectionStartBefore = e.target.selectionStartBefore || cursorPos;
      const selectionEndBefore = e.target.selectionEndBefore || cursorPos;
      
      // If there was a selection before the input
      if (selectionStartBefore !== selectionEndBefore) {
        // Text replacement: remove formatting from replaced text
        formattedRegions = formattedRegions.filter(region => {
          // Keep regions entirely outside the replaced area
          if (region.end <= selectionStartBefore || region.start >= selectionEndBefore) {
            return true;
          }
          
          // Split regions that span the selection
          const newRegions = [];
          
          // Keep part of region before selection
          if (region.start < selectionStartBefore) {
            newRegions.push({
              type: region.type,
              start: region.start,
              end: selectionStartBefore
            });
          }
          
          // Keep part of region after selection
          if (region.end > selectionEndBefore) {
            newRegions.push({
              type: region.type,
              start: selectionStartBefore, // New start is at insertion point
              end: region.end - (selectionEndBefore - selectionStartBefore) // Adjust end position
            });
          }
          
          // Add new split regions
          formattedRegions = formattedRegions.concat(newRegions);
          
          // Remove the original region
          return false;
        });
        
        // Apply formatting to inserted text if any format button is active
        const insertLength = cursorPos - selectionStartBefore;
        if (insertLength > 0) {
          applyActiveFormattingToRange(selectionStartBefore, cursorPos);
        }
        
        // Save the value for next comparison
        e.target.previousValue = contentInput.value;
        return;
      }
    }
    
    // Text was added (typing or pasting)
    if (changeInLength > 0) {
      // This is where we identify the insertion point
      let insertionPoint;
      
      // If we have previous content to compare
      if (previousContent) {
        // Find where the texts diverge (insertion point)
        for (insertionPoint = 0; insertionPoint < previousLength; insertionPoint++) {
          if (previousContent[insertionPoint] !== currentContent[insertionPoint]) {
            break;
          }
        }
        
        // If we didn't find where they differ and reached the end of previous content,
        // the insertion was at the end
        if (insertionPoint === previousLength) {
          insertionPoint = previousLength;
        }
      } else {
        // No previous content, so insert point is current cursor position
        insertionPoint = cursorPos - changeInLength;
      }
      
      // First adjust all regions after the insertion point
      formattedRegions = formattedRegions.map(region => {
        // If region starts after insertion, shift whole region
        if (region.start >= insertionPoint) {
          return {
            ...region,
            start: region.start + changeInLength,
            end: region.end + changeInLength
          };
        } 
        // If insertion is inside region, expand end point
        else if (region.end >= insertionPoint) {
          return {
            ...region,
            end: region.end + changeInLength
          };
        }
        // Otherwise, leave unchanged
        return region;
      });
      
      // Apply active formatting states to newly inserted text
      applyActiveFormattingToRange(insertionPoint, insertionPoint + changeInLength);
    }
    // Text was removed
    else if (changeInLength < 0) {
      // Find where deletion occurred
      const deletionStart = cursorPos;
      const deletionEnd = deletionStart - changeInLength; // Since changeInLength is negative
      
      // Update all formatting regions
      formattedRegions = formattedRegions.filter(region => {
        // Region ends before deletion - keep unchanged
        if (region.end <= deletionStart) {
          return true;
        }
        
        // Region starts after deletion end - shift start and end
        if (region.start >= deletionEnd) {
          region.start = region.start + changeInLength; // Shift back
          region.end = region.end + changeInLength; // Shift back
          return region.end > region.start; // Only keep valid regions
        }
        
        // Deletion completely contains region - remove region
        if (region.start >= deletionStart && region.end <= deletionEnd) {
          return false;
        }
        
        // Deletion overlaps start of region
        if (deletionStart <= region.start && deletionEnd > region.start && deletionEnd < region.end) {
          region.start = deletionStart;
          region.end = region.end + changeInLength;
          return region.end > region.start;
        }
        
        // Deletion overlaps end of region
        if (deletionStart > region.start && deletionStart < region.end && deletionEnd >= region.end) {
          region.end = deletionStart;
          return region.end > region.start;
        }
        
        // Deletion is inside region
        if (deletionStart > region.start && deletionEnd < region.end) {
          region.end = region.end + changeInLength;
          return true;
        }
        
        return false;
      });
    }
    
    // Save states for next comparison
    e.target.previousValue = contentInput.value;
    
    // Store selection state for future reference
    e.target.selectionStartBefore = contentInput.selectionStart;
    e.target.selectionEndBefore = contentInput.selectionEnd;
  }
  
  // Helper function to apply active formatting states to a range of text
  function applyActiveFormattingToRange(start, end) {
    if (start === end) return; // No range to format
    
    if (formatState.bold) {
      formattedRegions.push({
        type: 'bold',
        start: start,
        end: end
      });
    }
    
    if (formatState.italic) {
      formattedRegions.push({
        type: 'italic',
        start: start,
        end: end
      });
    }
    
    if (formatState.underline) {
      formattedRegions.push({
        type: 'underline',
        start: start,
        end: end
      });
    }
  }
    // Form validation
  postForm.addEventListener("submit", function(event) {
    event.preventDefault();
    
    // Update hidden content field before validation
    updateHiddenContent();
    
    // Clear all previous errors
    clearError(titleInput, "titleError");
    clearError(tagsInput, "tagsError");
    clearError(contentInput, "contentErr");
    
    let isValid = true;
    
    // Title validation
    if (!titleInput.value.trim()) {
      displayError(titleInput, "titleError", "Title cannot be empty");
      isValid = false;
    } else if (titleInput.value.length > 80) {
      displayError(titleInput, "titleError", "Title cannot exceed 80 characters");
      isValid = false;
    }
    
    // Tags validation
    if (!tagsInput.value.trim()) {
      displayError(tagsInput, "tagsError", "Please provide at least one tag");
      isValid = false;
    }
    
    // Content validation - check both the editor and hidden textarea
    if (!contentInput.value.trim()) {
      displayError(contentInput, "contentErr", "Post content cannot be empty");
      isValid = false;
    }
    
    // Submit if valid - convert formatted regions to markdown before submission
    if (isValid) {
      // Convert formatted regions to markdown for storage/processing
      const markdownContent = convertToMarkdown();
      
      // Create a hidden input to store the markdown version
      const markdownInput = document.createElement('input');
      markdownInput.type = 'hidden';
      markdownInput.name = 'markdown_content';
      markdownInput.value = markdownContent;
      postForm.appendChild(markdownInput);
      
      postForm.submit();
    }
  });
  
  // Helper functions for error handling
  function displayError(inputElement, errorId, errorMessage) {
    const errorElement = document.getElementById(errorId);
    errorElement.textContent = errorMessage;
    inputElement.classList.add("error");
  }
    function clearError(inputElement, errorId) {
    const errorElement = document.getElementById(errorId);
    errorElement.textContent = "";
    inputElement.classList.remove("error");
  }
  
  // Reset button handler
  resetBtn.addEventListener("click", function() {
    // Clear errors
    clearError(titleInput, "titleError");
    clearError(tagsInput, "tagsError");
    clearError(contentInput, "contentErr");
    
    // Reset character count
    titleCount.textContent = "0/80 characters";
    titleCount.classList.remove("warning", "danger");
    
    // Reset formatting
    resetFormatting();
  });
  
  // Get selection information
  function getSelectionInfo() {
    const textarea = contentInput;
    return {
      start: textarea.selectionStart,
      end: textarea.selectionEnd,
      text: textarea.value.substring(textarea.selectionStart, textarea.selectionEnd),
      hasSelection: textarea.selectionStart !== textarea.selectionEnd
    };
  }  // Apply formatting to selected text
  function applyFormatting(formatType) {
    const selection = getSelectionInfo();
    
    // If no text is selected, toggle formatting mode for next input
    if (!selection.hasSelection) {
      // Toggle active formatting state for next input
      formatState[formatType] = !formatState[formatType];
      updateFormatButtons();
      return;
    }
    
    const selStart = selection.start;
    const selEnd = selection.end;
    
    // Check if the entire selection already has this formatting
    const exactMatch = formattedRegions.find(region => 
      region.type === formatType && 
      region.start === selStart && 
      region.end === selEnd
    );
    
    if (exactMatch) {
      // If exact formatting exists, remove it (toggle off)
      formattedRegions = formattedRegions.filter(region => 
        !(region.type === formatType && 
          region.start === selStart && 
          region.end === selEnd)
      );
    } else {
      // Find any regions of this format type that overlap with the selection
      const overlappingRegions = formattedRegions.filter(region => 
        region.type === formatType && 
        ((region.start < selEnd && region.end > selStart))
      );
      
      // Remove overlapping regions
      if (overlappingRegions.length > 0) {
        formattedRegions = formattedRegions.filter(region => 
          !overlappingRegions.includes(region)
        );
        
        // Create new regions to preserve formatting outside the selection
        overlappingRegions.forEach(region => {
          // If region starts before selection, keep that part
          if (region.start < selStart) {
            formattedRegions.push({
              type: formatType,
              start: region.start,
              end: selStart
            });
          }
          
          // If region ends after selection, keep that part
          if (region.end > selEnd) {
            formattedRegions.push({
              type: formatType,
              start: selEnd,
              end: region.end
            });
          }
        });
      }
      
      // Add the new formatted region for the current selection
      formattedRegions.push({
        type: formatType,
        start: selStart,
        end: selEnd
      });
    }
    
    // Apply visual formatting immediately
    updateFormattedText();
    
    // Update buttons state
    updateFormatButtons();
  }  // Update the visual representation of the formatted text
  function updateFormattedText() {
    // Get editor container
    const editorContainer = document.getElementById('editor-container');
    if (!editorContainer) return;
    
    // Ensure the container has position relative
    editorContainer.style.position = 'relative';
    
    // Remove any existing preview element to avoid duplicates
    const existingPreview = document.getElementById('formatted-preview');
    if (existingPreview) {
      existingPreview.remove();
    }
    
    // Get content and prepare formatting
    const content = contentInput.value;
    
    // Create a new preview element
    const previewEl = document.createElement('div');
    previewEl.id = 'formatted-preview';
    previewEl.className = 'formatted-preview';
    
    // Insert the preview element as a sibling to the content input
    contentInput.parentNode.insertBefore(previewEl, contentInput.nextSibling);
    
    // Style the preview element to perfectly overlay the textarea
    previewEl.style.position = 'absolute';
    previewEl.style.top = '0';
    previewEl.style.left = '0';
    previewEl.style.width = '100%';
    previewEl.style.height = '100%';
    previewEl.style.backgroundColor = 'transparent';
    previewEl.style.zIndex = '2';
    previewEl.style.pointerEvents = 'none';
    previewEl.style.overflow = 'auto';
    previewEl.style.whiteSpace = 'pre-wrap';
    previewEl.style.padding = window.getComputedStyle(contentInput).padding;
    previewEl.style.boxSizing = 'border-box';
    previewEl.style.color = window.getComputedStyle(contentInput).color;
    previewEl.style.fontFamily = window.getComputedStyle(contentInput).fontFamily;
    previewEl.style.fontSize = window.getComputedStyle(contentInput).fontSize;
    previewEl.style.lineHeight = window.getComputedStyle(contentInput).lineHeight;
    
    // If there's no content or no formatting, just return
    if (!content || formattedRegions.length === 0) {
      previewEl.innerHTML = content ? escapeHTML(content) : '&nbsp;';
      previewEl.scrollTop = contentInput.scrollTop;
      return;
    }
    
    // Build segments of text with their formatting
    let segments = [{ text: content, formats: [] }];
    
    // Sort regions to ensure proper application
    const sortedRegions = [...formattedRegions].sort((a, b) => {
      // Sort by start position first
      if (a.start !== b.start) return a.start - b.start;
      // For same start, sort by end position (shorter regions first)
      return a.end - b.end;
    });
    
    // Apply each format to the segments
    for (const region of sortedRegions) {
      const { type, start, end } = region;
      
      // Skip invalid regions
      if (start < 0 || end > content.length || start >= end) continue;
      
      // Create new segments array to hold the result
      const newSegments = [];
      
      for (const segment of segments) {
        const segStart = segment.text.startIndexOf;
        const segEnd = segStart + segment.text.length;
        
        // Case 1: Region is completely outside this segment
        if (end <= segStart || start >= segEnd) {
          newSegments.push(segment);
          continue;
        }
        
        // Case 2: Region completely contains this segment
        if (start <= segStart && end >= segEnd) {
          newSegments.push({
            text: segment.text,
            formats: [...segment.formats, type]
          });
          continue;
        }
        
        // Case 3: Region starts before segment and ends inside
        if (start <= segStart && end < segEnd) {
          // Split into formatted and unformatted parts
          const formattedPart = segment.text.substring(0, end - segStart);
          const unformattedPart = segment.text.substring(end - segStart);
          
          newSegments.push({
            text: formattedPart,
            formats: [...segment.formats, type]
          });
          
          newSegments.push({
            text: unformattedPart,
            formats: [...segment.formats]
          });
          
          continue;
        }
        
        // Case 4: Region starts inside segment and ends after
        if (start > segStart && start < segEnd && end >= segEnd) {
          // Split into unformatted and formatted parts
          const unformattedPart = segment.text.substring(0, start - segStart);
          const formattedPart = segment.text.substring(start - segStart);
          
          newSegments.push({
            text: unformattedPart,
            formats: [...segment.formats]
          });
          
          newSegments.push({
            text: formattedPart,
            formats: [...segment.formats, type]
          });
          
          continue;
        }
        
        // Case 5: Region is completely inside this segment
        if (start > segStart && end < segEnd) {
          // Split into 3 parts: before, formatted, after
          const beforePart = segment.text.substring(0, start - segStart);
          const formattedPart = segment.text.substring(start - segStart, end - segStart);
          const afterPart = segment.text.substring(end - segStart);
          
          newSegments.push({
            text: beforePart,
            formats: [...segment.formats]
          });
          
          newSegments.push({
            text: formattedPart,
            formats: [...segment.formats, type]
          });
          
          newSegments.push({
            text: afterPart,
            formats: [...segment.formats]
          });
        }
      }
      
      segments = newSegments;
    }
    
    // Map the segments with formatting to HTML
    let html = '';
    
    // Simple character-by-character approach
    const formattingMap = new Array(content.length);
    for (let i = 0; i < content.length; i++) {
      formattingMap[i] = [];
    }
    
    // Apply each region's formatting to the map
    for (const region of sortedRegions) {
      for (let i = region.start; i < region.end && i < content.length; i++) {
        formattingMap[i].push(region.type);
      }
    }
    
    // Generate HTML using character formatting map
    let currentFormats = [];
    let buffer = '';
    
    for (let i = 0; i < content.length; i++) {
      const char = content[i];
      const formats = formattingMap[i] || [];
      
      // Sort formats for consistent comparison
      const sortedFormats = [...formats].sort();
      
      // Check if formatting changes
      const formatsChanged = !arraysEqual(currentFormats, sortedFormats);
      
      if (formatsChanged && buffer.length > 0) {
        // Output the current buffer with its formatting
        if (currentFormats.length > 0) {
          html += `<span class="${currentFormats.join(' ')}">${escapeHTML(buffer)}</span>`;
        } else {
          html += escapeHTML(buffer);
        }
        buffer = '';
        currentFormats = sortedFormats;
      }
      
      // Start new buffer with the current character
      if (buffer.length === 0) {
        currentFormats = sortedFormats;
      }
      
      buffer += char;
    }
    
    // Output any remaining text
    if (buffer.length > 0) {
      if (currentFormats.length > 0) {
        html += `<span class="${currentFormats.join(' ')}">${escapeHTML(buffer)}</span>`;
      } else {
        html += escapeHTML(buffer);
      }
    }
    
    // Update the preview and sync scrolling
    previewEl.innerHTML = html || '&nbsp;';
    previewEl.scrollTop = contentInput.scrollTop;
    
    // Helper function to compare arrays
    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
  }
  
  // Escape HTML special characters
  function escapeHTML(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  // Convert formatted content to markdown for storage or processing
  function convertToMarkdown() {
    const content = contentInput.value;
    
    // Early return if no content or formatting
    if (!content || formattedRegions.length === 0) {
      return content;
    }
    
    // Sort regions by end position (descending), then by start position (descending)
    // This ensures we process from the end of the text to the beginning
    // to avoid changing character positions as we insert markdown
    const sortedRegions = [...formattedRegions].sort((a, b) => {
      if (a.end !== b.end) return b.end - a.end;
      return b.start - a.start;
    });
    
    // Group regions by type for better processing
    const regionsByType = {
      bold: sortedRegions.filter(r => r.type === 'bold'),
      italic: sortedRegions.filter(r => r.type === 'italic'),
      underline: sortedRegions.filter(r => r.type === 'underline')
    };
    
    // We'll insert markdown tags starting from the end to avoid changing positions
    let markdownContent = content;
    
    // Process each format type in a specific order (bold, then italic, then underline)
    // to avoid nesting issues
    
    // First process bold regions
    for (const region of regionsByType.bold) {
      markdownContent = 
        markdownContent.substring(0, region.start) + 
        '**' + 
        markdownContent.substring(region.start, region.end) + 
        '**' + 
        markdownContent.substring(region.end);
    }
    
    // Then process italic regions
    for (const region of regionsByType.italic) {
      markdownContent = 
        markdownContent.substring(0, region.start) + 
        '_' + 
        markdownContent.substring(region.start, region.end) + 
        '_' + 
        markdownContent.substring(region.end);
    }
    
    // Finally process underline regions (using HTML tags as markdown doesn't have standard underline)
    for (const region of regionsByType.underline) {
      markdownContent = 
        markdownContent.substring(0, region.start) + 
        '<u>' + 
        markdownContent.substring(region.start, region.end) + 
        '</u>' + 
        markdownContent.substring(region.end);
    }
    
    return markdownContent;
  }// Clear formatting from selected text
  function clearFormattingFromSelection() {
    const selection = getSelectionInfo();
    
    if (!selection.hasSelection) {
      return; // Do nothing if no text is selected
    }
    
    // Track if anything was cleared for visual feedback
    let wasAnythingCleared = false;
    
    // Process each formatting type separately to avoid conflicts
    ['bold', 'italic', 'underline'].forEach(formatType => {
      // Find all regions of this format type that overlap with selection
      const affectedRegions = formattedRegions.filter(region => 
        region.type === formatType && 
        !(region.end <= selection.start || region.start >= selection.end)
      );
      
      if (affectedRegions.length > 0) {
        wasAnythingCleared = true;
        
        // Remove the affected regions
        formattedRegions = formattedRegions.filter(region => 
          !affectedRegions.includes(region)
        );
        
        // Add new regions for areas that should remain formatted
        affectedRegions.forEach(region => {
          // Check if the region extends before the selection
          if (region.start < selection.start) {
            formattedRegions.push({
              type: region.type,
              start: region.start,
              end: selection.start
            });
          }
          
          // Check if the region extends after the selection
          if (region.end > selection.end) {
            formattedRegions.push({
              type: region.type,
              start: selection.end,
              end: region.end
            });
          }
        });
      }
    });
    
    // Update the visual representation
    updateFormattedText();
    
    // Provide visual feedback only if something was changed
    if (wasAnythingCleared) {
      flashSelection();
    }
    
    // Update button states
    updateFormatButtons();
  }
  
  // Flash the selection to provide visual feedback
  function flashSelection() {
    // Get computed background color
    const computedStyle = window.getComputedStyle(contentInput);
    const originalBackground = computedStyle.backgroundColor;
    
    // Apply highlight
    contentInput.style.transition = 'background-color 0.3s ease';
    contentInput.style.backgroundColor = "#e0f0ff";
    
    // Remove highlight after a delay
    setTimeout(() => {
      contentInput.style.backgroundColor = originalBackground;
      
      // Clean up transition after animation completes
      setTimeout(() => {
        contentInput.style.transition = '';
      }, 300);
    }, 300);
  }
  
  // Reset all formatting
  function resetFormatting() {
    // Clear all format states
    formatState = {
      bold: false,
      italic: false,
      underline: false
    };
    
    // Clear all formatted regions
    formattedRegions = [];
    
    // Update the visual representation
    updateFormattedText();
    
    // Update buttons state - this will remove active classes
    updateFormatButtons();
  }// Update format buttons based on current state or cursor position
  function updateFormatButtons() {
    const selection = getSelectionInfo();
    
    // First, remove all active states
    boldBtn.classList.remove("active");
    italicBtn.classList.remove("active");
    underlineBtn.classList.remove("active");
    
    if (selection.hasSelection) {
      // If text is selected, check for formatting on the exact selection
      
      // Check if any bold region exactly matches the selection
      const hasBold = formattedRegions.some(region => 
        region.type === 'bold' && 
        region.start === selection.start && 
        region.end === selection.end
      );
      
      // Check if any italic region exactly matches the selection
      const hasItalic = formattedRegions.some(region => 
        region.type === 'italic' && 
        region.start === selection.start && 
        region.end === selection.end
      );
      
      // Check if any underline region exactly matches the selection
      const hasUnderline = formattedRegions.some(region => 
        region.type === 'underline' && 
        region.start === selection.start && 
        region.end === selection.end
      );
      
      // Apply active class if the selection has the formatting
      if (hasBold) boldBtn.classList.add("active");
      if (hasItalic) italicBtn.classList.add("active");
      if (hasUnderline) underlineBtn.classList.add("active");
    } else {
      // If no text is selected, use the format state for typing mode
      if (formatState.bold) boldBtn.classList.add("active");
      if (formatState.italic) italicBtn.classList.add("active");
      if (formatState.underline) underlineBtn.classList.add("active");
    }
  }
    // Event listeners for text selection
  contentInput.addEventListener('mouseup', updateFormatButtons);
  contentInput.addEventListener('keyup', function(e) {
    // Only update on arrow keys, home/end, etc.
    if (e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End' || 
        e.key === 'PageUp' || e.key === 'PageDown') {
      updateFormatButtons();
    }
  });
  
  // Sync scrolling between textarea and preview
  contentInput.addEventListener('scroll', function() {
    const previewEl = document.getElementById('formatted-preview');
    if (previewEl) {
      previewEl.scrollTop = contentInput.scrollTop;
      previewEl.scrollLeft = contentInput.scrollLeft;
    }
  });  // Event listeners for formatting buttons
  boldBtn.addEventListener("click", function() {
    // Store selection before applying formatting
    const hadSelection = getSelectionInfo().hasSelection;
    
    // Apply the formatting
    applyFormatting("bold");
    
    // Return focus to the content area
    contentInput.focus();
    
    // If text was selected, we don't want to enable format mode
    if (hadSelection) {
      formatState.bold = false;
    }
    
    // Update the button states
    updateFormatButtons();
  });
  
  italicBtn.addEventListener("click", function() {
    // Store selection before applying formatting
    const hadSelection = getSelectionInfo().hasSelection;
    
    // Apply the formatting
    applyFormatting("italic");
    
    // Return focus to the content area
    contentInput.focus();
    
    // If text was selected, we don't want to enable format mode
    if (hadSelection) {
      formatState.italic = false;
    }
    
    // Update the button states
    updateFormatButtons();
  });
  
  underlineBtn.addEventListener("click", function() {
    // Store selection before applying formatting
    const hadSelection = getSelectionInfo().hasSelection;
    
    // Apply the formatting
    applyFormatting("underline");
    
    // Return focus to the content area
    contentInput.focus();
    
    // If text was selected, we don't want to enable format mode
    if (hadSelection) {
      formatState.underline = false;
    }
    
    // Update the button states
    updateFormatButtons();
  });
  
  clearSelectedBtn.addEventListener("click", function() {
    clearFormattingFromSelection();
    contentInput.focus();
  });
  
  resetFormatBtn.addEventListener("click", function() {
    resetFormatting();
    contentInput.focus();
  });
});
